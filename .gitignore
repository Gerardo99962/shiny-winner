backend
frontend
README.md
ETHICS.mdfrom fastapi import FastAPI

app = FastAPI()

@app.get("/")
def health_check():
    return {"status": "ok"}

@app.post("/search")
def search():
    return {
        "summary": "Example public signals",
        "confidence": "Low",
        "signals": [
            {
                "source": "demo",
                "description": "This is a placeholder public signal.",
                "weight": 0.1,
                "timestamp": "2023-01-01T00:00:00",
                "url": "https://example.com"
            }
        ]
    }from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def health_check():
    return {"status": "ok"}

@app.post("/search")
def search():
    return {
        "summary": "Example public signals",
        "confidence": "Low",
        "signals": [
            {
                "source": "demo",
                "description": "This is a placeholder public signal.",
                "weight": 0.1,
                "timestamp": "2023-01-01T00:00:00",
                "url": "https://example.com"
            }
        ]
    }pip install fastapi uvicorn
uvicorn main:app --reload8e0b3817fb476900257f7c5fe9c99b5b93e199dfbackend/
frontend/
README.md
ETHICS.mdopen-public-searchopen-public-search/
│
├── backend/
│   ├── app/
│   │   ├── api/
│   │   ├── models/
│   │   ├── services/
│   │   └── main.py
│   └── requirements.txt
│
├── frontend/
│   ├── app/
│   ├── components/
│   └── package.json
│
├── README.md
└── ETHICS.md@router.post("/", response_model=SearchResult)
def search(request: SearchRequest):
    result = perform_search(
        query=request.query,
        region=request.region,
        platforms=request.platforms,
    )
    return resultconst [platforms, setPlatforms] = useState<string[]>([])<div className="mb-4">
  <p className="text-sm font-medium mb-2">Filter by platform</p>

  <div className="flex gap-4">
    {availablePlatforms.map((platform) => (
      <label key={platform} className="flex items-center gap-2 text-sm">
        <input
          type="checkbox"
          checked={platforms.includes(platform)}
          onChange={(e) => {
            if (e.target.checked) {
              setPlatforms([...platforms, platform])
            } else {
              setPlatforms(platforms.filter(p => p !== platform))
            }
          }}
        />
        {platform}
      </label>
    ))}
  </div>
</div>from typing import List, Optional

class SearchRequest(BaseModel):
    query: str
    region: Optional[str] = None
    platforms: Optional[List[str]] = Nonetype Signal = {
  source: string
  description: string
  weight: number
  timestamp: string
  url: string
}

export function Timeline({ signals }: { signals: Signal[] }) {
  return (
    <div className="border-l pl-6 space-y-8">
      {signals.map((signal, index) => (
        <div key={index} className="relative">
          {/* Dot */}
          <div className="absolute -left-3 top-1 w-2 h-2 bg-black rounded-full" />

          {/* Content */}
          <div>
            <time className="text-sm text-gray-500">
              {new Date(signal.timestamp).toLocaleDateString()}
            </time>

            <p className="mt-1 text-sm">
              {signal.description}
            </p>

            <div className="mt-1 flex items-center gap-3 text-xs text-gray-600">
              <span>Source: {signal.source}</span>
              <span>Signal weight: {signal.weight}</span>
              <a
                href={signal.url}
                target="_blank"
                className="underline"
              >
                View source
              </a>
            </div>
          </div>
        </div>
      ))}
    </div>
  )
}'use client'

import { useState } from 'react'

type Signal = {
  source: string
  description: string
  weight: number
  timestamp: string
  url: string
}

export default function SearchPage() {
  const [query, setQuery] = useState('')
  const [result, setResult] = useState<any>(null)
  const [loading, setLoading] = useState(false)

  async function handleSearch() {
    setLoading(true)
    const res = await fetch('http://localhost:8000/search/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query }),
    })

    const data = await res.json()
    setResult(data)
    setLoading(false)
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      {/* Search */}
      <div className="mb-8">
        <input
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search name or username"
          className="w-full p-3 border rounded-md"
        />
        <button
          onClick={handleSearch}
          className="mt-3 px-4 py-2 bg-black text-white rounded-md"
        >
          Search
        </button>
      </div>

      {loading && <p>Searching public sources…</p>}

      {/* Results */}
      {result && (
        <>
          <div className="mb-6">
            <h2 className="text-xl font-semibold">Public Presence Summary</h2>
            <p className="text-sm text-gray-600">{result.summary}</p>

            <div className="mt-2 inline-block px-3 py-1 rounded-full text-sm border">
              Confidence: <strong>{result.confidence}</strong>
            </div>
          </div>

          <Timeline signals={result.signals} />
        </>
      )}
    </div>
  )
}{
  "summary": "Public presence signals found for 'query'",
  "confidence": "Medium",
  "signals": [
    {
      "source": "public_forum",
      "description": "Public post mentioning query...",
      "weight": 0.3,
      "timestamp": "2022-08-14T10:23:00",
      "url": "https://example.com/post"
    }
  ]
}uvicorn app.main:app --reloaddocker run -d \
  -p 9200:9200 \
  -e "discovery.type=single-node" \
  -e "plugins.security.disabled=true" \
  opensearchproject/opensearch:latestclass Signal(BaseModel):
    source: str
    description: str
    weight: float
    timestamp: str
    url: strfrom app.core.opensearch import client
from app.scoring.confidence import score_confidence

INDEX_NAME = "public_signals"

def perform_search(query: str, region: str | None):
    search_query = {
        "query": {
            "match": {
                "content": query
            }
        },
        "sort": [
            {"timestamp": {"order": "asc"}}
        ],
        "size": 50
    }

    response = client.search(
        index=INDEX_NAME,
        body=search_query
    )

    signals = []
    for hit in response["hits"]["hits"]:
        src = hit["_source"]
        signals.append({
            "source": src["platform"],
            "description": src["content"][:120],
            "weight": src["weight"],
            "timestamp": src["timestamp"],
            "url": src["url"],
        })

    confidence = score_confidence(signals)

    return {
        "summary": f"Public presence signals found for '{query}'",
        "confidence": confidence,
        "signals": signals,
    }from app.core.opensearch import client
from datetime import datetime

INDEX_NAME = "public_signals"

def index_signal(
    query_term: str,
    platform: str,
    content: str,
    timestamp: datetime,
    url: str,
    signal_type: str,
    weight: float,
):
    document = {
        "query_term": query_term,
        "platform": platform,
        "content": content,
        "timestamp": timestamp,
        "url": url,
        "signal_type": signal_type,
        "weight": weight,
    }

    client.index(index=INDEX_NAME, body=document)from app.core.opensearch import client
from app.core.mappings import PUBLIC_SIGNAL_INDEX

INDEX_NAME = "public_signals"

def ensure_index():
    if not client.indices.exists(INDEX_NAME):
        client.indices.create(
            index=INDEX_NAME,
            body=PUBLIC_SIGNAL_INDEX
        )# Google App Engine generated folder
appengine-generated/
